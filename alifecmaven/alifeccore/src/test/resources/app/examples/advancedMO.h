// =======================================================
// Generated by alifecontest-java application.
//   @author: Sergio
//   @email:sergio.jose.delcastillo@gmail.com
// =======================================================

#ifndef ADVANCED_H
#define ADVANCED_H

#include<cstdlib>
#include <iostream>
#include <vector>
using namespace std;


#include "Petri.h"
#include "Defs.h"
#include "Microorganism.h"


class AdvancedMO: public Microorganism{
   float his_emax;
   float my_emax;
   float my_nmax;
   
	public:
		AdvancedMO(){
		}

		void move(Movement &mov) {
      	mov.dx = mov.dy = his_emax = my_emax= 0;
	                  
         for(int ds = 1; ds < Defs::RADIUS/2; ds++){
				// Obtener todas las posiciones de nutrientes en donde no hay aliados que 
				// corresponden a una distancia ds de mi microorganismo. 
            vector<Position> list = find(ds);

				// Por cada posición que tiene una distancia ds
            for(unsigned i = 0; i < list.size(); i++){


              if(can_attack(list[i], ds)) {
					  // si puedo atacar creo un movimiento relativo
                 mov.dx = relative(x, list[i].x);
                 mov.dy = relative(y, list[i].y);
                 
					  //si el movimiento relativo es válido. Puede ser que quede fuera del plato cuando se
  					  //hace relativo o también puede pasar que caiga en una posición
					  //en donde está un aliado
                 if( !petri.inDish(x+mov.dx, y+mov.dy) ||
                     petri.getOpponent(x, y) == petri.getOpponent(x+mov.dx, y+mov.dy)){
                     mov.dx = mov.dy = 0;
                  }
                  return;
               } else if(can_move(list[i], ds)){
					  // si puedo moverme a algun lugar donde hay mayor nutriente
                  mov.dx = relative(x, list[i].x);
                  mov.dy = relative(y, list[i].y);
                     
						// verifico que el movimiento relativo sea válido
                  if(!petri.inDish(x+mov.dx, y+mov.dy) ||
                     petri.getOpponent(x+mov.dx, y +mov.dy) >= 0){
                     mov.dx = mov.dy = 0;
                  }
                  return;
               }
            }
         }         

		};

		bool mitosis(){
			return false;
		};

		string getName(){
			return "Advanced_cpp";
		};

		string getAuthor(){
			return "Judge";
		};

		string getAffiliation(){
			return "Judge";
		};

		/*retorna true si el microorganismo de la posición p puede ser atacado por mi MO*/
		bool can_attack(Position p, int ds){
		   return /* si puedo pelear*/ 
				    petri.canCompete(x, y, p.x, p.y) &&
				    /* si considero que puedo moverme para poder atacar con seguridad*/
                petri.getEnergy(p.x, p.y)+ petri.getNutrient(p.x, p.y)*(ds-1) < 
					 petri.getEnergy(x, y)-ds*ds*(Defs::LESS_MOVE+Defs::LESS_LIVE);
					 
      }

		bool can_move(Position p, int ds){
			return /*si considero que puedo moverme con seguridad*/
					 petri.getNutrient(p.x, p.y) -(Defs::LESS_LIVE+ Defs::LESS_MOVE)*ds*ds  > 
					 1.56*petri.getNutrient(x, y);
		}

	   /*Obtener todas las posiciones que no están ocupadas por un alidado en un radio ds de mi posición */
		vector<Position> find(int ds){
		   vector<Position> list;
		   int id = petri.getOpponent(x, y);

		   for(int i = -ds; i<= ds; i++){
		      eval(list, x+i, y+ds, id);
		   }  
		   
  		   for(int i = -ds; i<= ds; i++){
  		      eval(list, x+i, y-ds, id);
		   }

		   for(int i = -ds; i<= ds; i++){
		      eval(list, x+ds, y+i, id);
		   }  

		   for(int i = -ds; i<= ds; i++){
 		      eval(list, x-ds, y+i, id);
		   }  

         return list;
		}
		/* Agregar la posición (x,y) si esta dentro del plato y además no está ocupada por un aliado.
			Además se actualizan las variables de su energia máxima (his_emax) y de mi energia máxima(my_emax)
	   */
		void eval(vector<Position>& v, int x, int y, int id){
         if(!petri.inDish(x, y)) return;
         
		   if(petri.getOpponent(x, y) == id){
   		   if(petri.getEnergy(x, y) > my_emax){
                my_emax = petri.getEnergy(x, y);
		      }
		   }else{
            Position p;
            p.x = x;
            p.y = y;
            v.push_back(p);
            
            if(petri.getEnergy(x, y) > his_emax){
               his_emax = petri.getEnergy(x, y);
            }
            if(petri.getOpponent(x, y) < 0 && petri.getNutrient(x, y) > my_nmax){
               my_nmax = petri.getNutrient(x, y);
            }
         } 
		}
		// relativizar un movimiento
		int relative(int a, int b){
		   if(a < b) return 1;
		   else return (a > b) ? -1: 0;
		}
};

#endif

