// =======================================================
// Generated by alifecontest-java application.
//   @author Sergio
//   @e-mail:sergiodelcastillo@ymail.com
// =======================================================

#ifndef ADVANCED_H
#define ADVANCED_H

#include<cstdlib>
#include <iostream>
#include <vector>
using namespace std;

#include "Defs.h"
#include "Microorganism.h"

class AdvancedMO: public Microorganism{
   float his_emax;
   float my_emax;
   float my_nmax;
   
	public:
		AdvancedMO(){
		}

		void move(Movement &mov) {
      	mov.dx = mov.dy = his_emax = my_emax= 0;
        	                  
         for(int ds = 1; ds < Defs::RADIUS/2; ds++){
				// Obtener todas las posiciones de nutrientes en donde no hay aliados que 
				// corresponden a una distancia ds de mi microorganismo. 
            vector<Position> list = find(ds);

				// Por cada posición que tiene una distancia ds
            for(unsigned i = 0; i < list.size(); i++){


              if(can_attack(list[i], ds)) {
					  // si puedo atacar creo un movimiento relativo
                 mov.dx = relative(pos.x, list[i].x);
                 mov.dy = relative(pos.y, list[i].y);
                 
					  //si el movimiento relativo es válido. Puede ser que quede fuera del plato cuando se
  					  //hace relativo o también puede pasar que caiga en una posición
					  //en donde está un aliado y para evitar que el entorno me penalice no me muevo.
                 if( !Petri::getInstance()->inDish(pos.x+mov.dx, pos.y+mov.dy) ||
                     Petri::getInstance()->getOpponent(pos.x, pos.y) == Petri::getInstance()->getOpponent(pos.x+mov.dx, pos.y+mov.dy)){
                     mov.dx = mov.dy = 0;
                  }
                  return;
               } else if(can_move(list[i], ds)){
					  // si puedo moverme a algun lugar donde hay mayor nutriente
                  mov.dx = relative(pos.x, list[i].x);
                  mov.dy = relative(pos.y, list[i].y);
                     
						// verifico que el movimiento relativo sea válido
                  if(!Petri::getInstance()->inDish(pos.x+mov.dx, pos.y+mov.dy) ||
                     Petri::getInstance()->getOpponent(pos.x+mov.dx, pos.y +mov.dy) >= 0){
                     mov.dx = mov.dy = 0;
                  }
                  return;
               }
            }
         }         

		};

		bool mitosis(){
			return false;
		};

		string getName(){
			return "Advanced_cpp";
		};

		string getAuthor(){
			return "Judge";
		};

		string getAffiliation(){
			return "Judge";
		};

		/*retorna true si el microorganismo de la posición p puede ser atacado por mi MO*/
		bool can_attack(Position p, int ds){
		   return /* si puedo pelear*/ 
				    Petri::getInstance()->canCompete(pos, p) &&
				    /* si considero que puedo moverme para poder atacar con seguridad*/
                    Petri::getInstance()->getEnergy(p.x, p.y) < Petri::getInstance()->getEnergy(pos.x, pos.y)-ds*ds &&
					 /* si es su MO más gordito conocido en el radio ds y si es uno de mis MOs mas gorditos */
                    Petri::getInstance()->getEnergy(p.x, p.y) >= 100 && Petri::getInstance()->getEnergy(pos.x, pos.y) >= my_emax/1.3f ;
      }

		bool can_move(Position p, int ds){
			return /*si considero que puedo moverme con seguridad*/
					 Petri::getInstance()->getNutrient(p.x, p.y) -(Defs::LESS_LIVE+ Defs::LESS_MOVE)*ds*ds  >
					 1.5*Petri::getInstance()->getNutrient(pos.x, pos.y);
		}

	   /*Obtener todas las posiciones que no están ocupadas por un alidado en un radio ds de mi posición */
		vector<Position> find(int ds){
		   vector<Position> list;
		   int id = Petri::getInstance()->getOpponent(pos.x, pos.y);

		   for(int i = -ds; i<= ds; i++){
		      eval(list, pos.x+i, pos.y+ds, id);
		   }  
		   
  		   for(int i = -ds; i<= ds; i++){
  		      eval(list, pos.x+i, pos.y-ds, id);
		   }  

		   for(int i = -ds; i<= ds; i++){
		      eval(list, pos.x+ds, pos.y+i, id);		      
		   }  

		   for(int i = -ds; i<= ds; i++){
 		      eval(list, pos.x-ds, pos.y+i, id);
		   }  

         return list;
		}
		/* Agregar la posición (x,y) si esta dentro del plato y además no está ocupada por un aliado.
			Además se actualizan las variables de su energia máxima (his_emax) y de mi energia máxima(my_emax)
	   */
		void eval(vector<Position>& v, int x, int y, int id){
         if(!Petri::getInstance()->inDish(x, y)) return;
         
		   if(Petri::getInstance()->getOpponent(x, y) == id){
   		   if(Petri::getInstance()->getEnergy(x, y) > my_emax){
                my_emax = Petri::getInstance()->getEnergy(x, y);
		      }
		   }else{
            Position p;
            p.x = x;
            p.y = y;
            v.push_back(p);
            
            if(Petri::getInstance()->getEnergy(x, y) > his_emax){
               his_emax = Petri::getInstance()->getEnergy(x, y);
            }
            if(Petri::getInstance()->getOpponent(x, y) < 0 && Petri::getInstance()->getNutrient(x, y) > my_nmax){
               my_nmax = Petri::getInstance()->getNutrient(x, y);
            }
         } 
		}
		// relativizar un movimiento
		int relative(int a, int b){
		   if(a < b) return 1;
		   else return (a > b) ? -1: 0;
		}
};

#endif

